# ✅ 알고리즘
컴퓨터로 문제를 풀기 위한 단계적인 절차

### 알고리즘의 조건
- 입력: 0개 이상의 입력 (= 있든 없든 ok)
- 출력: 1개 이상의 출력 (1개 이상의 실행 결과)
- 명백성: 각 명령어의 의미가 명확
- 유한성: 한정된 수의 단계 후에는 반드시 종료
- 유효성: 각 명령어들은 실행 가능한 연산임

*자료형: 데이터의 종류
- 데이터의 집합
- 데이터에 적용할 수 있는 _연산의 집합_

*✅ 추상 자료형
- 자료의 집합(객체) & 그 자료를 대상으로 행해지는 연산(-인터페이스 역할)
- 자료와 연산이 무엇(what)인가는 정의되지만 자료와 연산을 컴퓨터 상에서 어떻게(how) 구현할 것인지는 정의되지 않음
- 만약 다른 사람이 추상 데이터 타입의 구현을 변경하더라도 인터페이스가 변경되지 않으면 사용자들은 여전히 추상데이터 타입을 같은 방식으로 사용할 수 있다.

# 알고리즘의 성능 분석
### 프로그램의 효율성
- 실행 시간이 짧아야 한다.
- 컴퓨터 내에 있는 자원을 적게 사용하여야 한다.

### 성능 분석 기법
- 수행 시간 측정
  - 실제 구현 필요
  - 실제 수행 시간 측정(여러번, 다양한 데이터로 수행 필요)
- 알고리즘의 복잡도 분석
  - 직접 구현 X
  - `연산의 횟수(=입력의 개수 n)`를 측정하여 비교 ➡️ 실행 하드웨어나 소프트웨어 환경과 관계 없이 평가 가능

# ✅ 표기법
- Big-O 표기법: 함수의 상한
  - |f(n)|≤c|g(n)| ➡️ f(n) = O(g(n))
  - 영향을 가장 크게 미치는 최고차 항만을 고려. 계수도 버림
- Big-Omega 표기법 ; 함수의 하한
  - |f(n)|≥c|g(n)| ➡️ f(n) = O(g(n))
- Big-Theta 표기법; 함수의 하한과 상한(동시)

*f(n)=2n+1, g(n)=n<sup>2</sup> ➡️ O(n<sup>2</sup>) 맞음! but 꼭 맞는 것을 찾는 게 더 정확
