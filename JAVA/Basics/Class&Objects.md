# OOP__Objective-Oriented Programming Language
*객체 = 데이터(➡고유한 특성, 변수) + 기능
- 객체를 기반으로 프로그램을 작성하는 언어 
- **부품객체**를 먼저 만들고 **하나씩 조립**해 가는 프로그램 기법
- 객체지향 기법의 3R
  - 가독성 Readability
  - 재사용성 Reusability
  - 신뢰성 Reliability

*객체를 만들기 위해서는 Class가 필요하다.

### 객체지향 프로그램이 갖추어야 할 속성
 - 상속성 Inheritance
 - 은닉성 Information Hiding, Encapsulation
 - 다형성 Polymorphism

## 캡슐화__불필요한 건 숨기고 약속된 것만 꺼내자!
![image](https://user-images.githubusercontent.com/56028436/113539055-ca74d280-9617-11eb-9e5f-a4319fce5429.png)
- 약속되지 않은 부분 / 보여줄 필요가 없는 부분은 감싸서 숨겨버리는 것
- 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것
- 외부 객체는 객체 내부 구조를 알 수 X, 객체가 노출해 제공하는 필드와 메소드만 이용 가능

➡ 외부 사용으로 인한 객체 손상 방지, 캡슐화된 멤버의 노출 여부 결정(접근 제한자: public/private/protected)

### 자바의 캡슐화__클래스와 객체
- Class: 객체 모양을 선언한 틀. 메소드(멤버 함수)와 필드(멤버 변수)는 모두 클래스 내에 구현
- 객체: **클래스의 모양대로 생성된 실체(instance)**
  - 객체 내 데이터에 대한 보호, 외부 접근 제한 __ 객체 외부에서는 공개된 메소드로 비공개 멤버에 접근(직접 접근X)
  - 객체 외부에서 비공개 멤버에 직접 접근할 수 없도록 `private`

## 상속__공통부분은 재사용!
*상위 객체로 갈수록 추상화, 일반화되고 하위 객체로 갈수록 상세화된다.
- 상속 대상: 상위 개체의 필드와 메소드. 생성자는 상속되지 X
- 상속 조건: A is B가 **물리적/개념적으로 타당할 때만** 상속.
- 하위 객체가 상위 개체의 속성과 메소드를 모두 사용
- `Is-A` : 새로운 클래스 A가 기존 클래스 B를 물려받았을 때, `A는 B이다!`가 성립 ➡ `Class A Is-A Class B`

➡ 반복된 코드를 줄임, 유지 보수의 편리성 증가, 객체의 `다형성` 구현

### 자바의 상속
- 부모 클래스 = 수퍼 클래스 = 상위 클래스
- 자식 클래스 = 서브 클래스 = 하위 클래스
  - 수퍼 클래스를 재사용하고 새로운 특성 추가
